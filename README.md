# ClassLoader
Android ClassLoader 总结

> JVM VS  Dalvik

Android应用程序运行在Dalvik/ART虚拟机上，并且一个应用程序对应一个单独的Dalvik虚拟机实例。
Dalvik虚拟机实际上也可以算是一个Java虚拟机，只不过它执行的不是class文件，而是dex文件。
Dalvik虚拟机与java虚拟机共享差不多的特性，差别在于两者指行的指令集不一样，前者的指令集时基于寄存器，后者的指令是基于堆栈的 
另外一点class文件是一个文件一个class,dex文件则是一个文件多个class


> 什么是基于栈的虚拟机，什么是基于寄存器的虚拟机

对于基于栈的虚拟机来讲，每一个运行的线程都有自己私有的虚拟机栈，栈中记录了方法的调用历史，每一次调用方法会对应生成一个栈帧压入虚拟机栈，每一栈帧又包含局部变量表、操作数栈、动态链接、返回地址这几部分。详细可以参考![](https://github.com/ZhongXiaoHong/JVM)

寄存器是CPU的一部分，是一个有限存储容量的高速存储部件，可以用来暂存指令、数据
![](https://github.com/ZhongXiaoHong/ClassLoader/blob/master/61788888.jpg)

运行大致过程如下：
首先根据当前的程序计数器，从指令集读取指令，交给指令寄存器，转化为CPU指令，比如上图 0 号指令表示去加载地址为100的数值1到数据寄存器AX,
1 号指令表示去加载地址为104的数值1到数据寄存器BX,2 号指令将A 、B数据寄存器通过ALU算数逻辑单元计算之后将结果保存在CX，3 号指令将数据寄存器CX数值保存在108地址上


基于寄存器的虚拟机
基于寄存器的虚拟机没有操作数栈，局部变量表，但是有很多虚拟寄存器，相当于虚拟寄存器把操作数栈，局部变量表给合并了。和操作数栈相同，这些虚拟的寄存器也是存放在运行时栈中，本质上是一个数组，与JVM相似，在DalvikVM中每个线程都有自己的程序计数器、调用栈，方法调用生成的栈帧也是会进入调用栈的,虚拟寄存器实际上就是模拟了基于栈的虚拟机中的栈帧的操作数栈压栈出栈计算然后在压栈到局部变量表的过程，实际上虚拟寄存器可以看成对这个步骤的优化，做同样的事用更简单的方式

那基于栈的虚拟机栈与基于寄存器的虚拟机有什么区别呢？

```java
   public void test() {
        int a = 1;
        int b = 2;
        int c = a + b;
    }

```
基于栈的虚拟机生成的指令集如下：

![](https://github.com/ZhongXiaoHong/ClassLoader/blob/master/6179999999999999999.jpg)

基于寄存器的虚拟机

![](https://github.com/ZhongXiaoHong/ClassLoader/blob/master/617666666666666.jpg)

可以发现基于寄存器的指令数明显减少，数据移动次数也减少

**Android虚拟机Dalvik、ART都是基于寄存器的虚拟机**


> ART VS Dalvik

Dalvik虚拟机运行的是dex字节码，解释执行（首先要先翻译成机器码，然后在执行），Android2.2之后又支持JIT即时编译,在程序运行的过程中选择热点代码（经常执行的代码）进行编译成机器码，所以Dalvik是解释执行+JIT，apk安装的时候会执行一个dexopt操作，将dex文件转化成Odex文件。

ART虚拟机执行的是本地机器码，
apk安装的时候会利用dex2oat工具，将dex文件编译成本地机器码，这个过程被称为预先编译机制AOT（Ahead  of Time）


**android 5.0开始正式切换到ART,Android的5.0、6.0安装apk会比较慢，这是因为安装的时候多了编译机器码的过程（AOT）,所以在Android N (7.0)之后又做了优化**

**ART 在Android N 之后的优化：**

应用安装时不作AOT,运行过程中解释执行，对经常调用的方法进行JIT,经过JIT编译的方法会记录到profile配置文件中，在手机充电等有空闲的场景下，编译守护进程会运行，根据profile文件对常用代码进行AOT编译生成art文件，待下次运行直接使用


28：10















